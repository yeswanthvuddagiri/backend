"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDeviceId = getDeviceId;
const crypto_1 = require("crypto");
function getDeviceId({ getMachineId, onError, timeout = 3000, abortSignal, fallbackValue = 'unknown', }) {
    let timeoutId;
    const value = Promise.race([
        resolveMachineId({
            getMachineId,
            onError,
        }),
        new Promise((resolve) => {
            abortSignal?.addEventListener('abort', () => {
                onError?.('abort', new Error('Aborted by abort signal'));
                resolve(fallbackValue);
            });
            timeoutId = setTimeout(() => {
                onError?.('timeout', new Error(`Timeout reached after ${timeout} ms`));
                resolve(fallbackValue);
            }, timeout).unref?.();
        }),
    ]).finally(() => clearTimeout(timeoutId));
    return value;
}
async function resolveMachineId({ getMachineId, onError, }) {
    try {
        const originalId = (await getMachineId())?.toUpperCase();
        if (!originalId) {
            onError?.('resolutionError', new Error('Failed to resolve machine ID'));
            return 'unknown';
        }
        const hmac = (0, crypto_1.createHmac)('sha256', originalId);
        const DEVICE_ID_HASH_MESSAGE = 'atlascli';
        hmac.update(DEVICE_ID_HASH_MESSAGE);
        return hmac.digest('hex');
    }
    catch (error) {
        onError?.('resolutionError', error);
        return 'unknown';
    }
}
//# sourceMappingURL=get-device-id.js.map