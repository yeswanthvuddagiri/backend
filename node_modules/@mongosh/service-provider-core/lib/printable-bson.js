"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePrintableBson = exports.bsonStringifiers = void 0;
const bson_export_1 = require("./bson-export");
const util_1 = require("util");
const inspectCustom = Symbol.for('nodejs.util.inspect.custom');
function removeNewFromInspectResult(str) {
    return str.replace(/^(\s*)(new )/, '$1');
}
function removeTypedArrayPrefixFromInspectResult(str) {
    return str.replace(/^\s*\S+\s*\(\d+\)\s*/, '');
}
function makeClasslessInspect(className) {
    const originalInspect = bson_export_1.bson[className].prototype.inspect;
    return function (...args) {
        return removeNewFromInspectResult(originalInspect.apply(this, args));
    };
}
const binaryInspect = makeClasslessInspect('Binary');
const binaryVectorInspect = function (depth, options) {
    switch (this.buffer[0]) {
        case bson_export_1.bson.Binary.VECTOR_TYPE.Int8:
            return `Binary.fromInt8Array(new Int8Array(${removeTypedArrayPrefixFromInspectResult((0, util_1.inspect)(this.toInt8Array(), {
                depth,
                ...options,
                maxArrayLength: util_1.inspect.defaultOptions.maxArrayLength,
            }))}))`;
        case bson_export_1.bson.Binary.VECTOR_TYPE.Float32:
            return `Binary.fromFloat32Array(new Float32Array(${removeTypedArrayPrefixFromInspectResult((0, util_1.inspect)(this.toFloat32Array(), {
                depth,
                ...options,
                maxArrayLength: util_1.inspect.defaultOptions.maxArrayLength,
            }))}))`;
        case bson_export_1.bson.Binary.VECTOR_TYPE.PackedBit: {
            const paddingInfo = this.buffer[1] === 0 ? '' : `, ${this.buffer[1]}`;
            return `Binary.fromPackedBits(new Uint8Array(${removeTypedArrayPrefixFromInspectResult((0, util_1.inspect)(this.toPackedBits(), {
                depth,
                ...options,
                maxArrayLength: util_1.inspect.defaultOptions.maxArrayLength,
            }))})${paddingInfo})`;
        }
        default:
            return binaryInspect.call(this, depth, options);
    }
};
exports.bsonStringifiers = {
    ObjectId: makeClasslessInspect('ObjectId'),
    ObjectID: makeClasslessInspect('ObjectId'),
    DBRef: makeClasslessInspect('DBRef'),
    MaxKey: makeClasslessInspect('MaxKey'),
    MinKey: makeClasslessInspect('MinKey'),
    Timestamp: makeClasslessInspect('Timestamp'),
    BSONSymbol: makeClasslessInspect('BSONSymbol'),
    Code: makeClasslessInspect('Code'),
    Decimal128: makeClasslessInspect('Decimal128'),
    Int32: makeClasslessInspect('Int32'),
    Long: makeClasslessInspect('Long'),
    Double: makeClasslessInspect('Double'),
    BSONRegExp: makeClasslessInspect('BSONRegExp'),
    Binary: function (...args) {
        const hexString = this.toString('hex');
        switch (this.sub_type) {
            case bson_export_1.bson.Binary.SUBTYPE_VECTOR:
                return binaryVectorInspect.apply(this, args);
            case bson_export_1.bson.Binary.SUBTYPE_MD5:
                return `MD5('${hexString}')`;
            case bson_export_1.bson.Binary.SUBTYPE_UUID:
                if (hexString.length === 32) {
                    const asUUID = /^(.{8})(.{4})(.{4})(.{4})(.{12})$/
                        .exec(hexString)
                        .slice(1, 6)
                        .join('-');
                    return `UUID('${asUUID}')`;
                }
            default:
                return binaryInspect.apply(this, args);
        }
    },
};
function makePrintableBson(bson) {
    if (!bson) {
        bson = bson_export_1.bson;
    }
    for (const [key, stringifier] of Object.entries(exports.bsonStringifiers)) {
        if (!(key in bson)) {
            continue;
        }
        const cls = bson[key];
        for (const key of [inspectCustom, 'inspect']) {
            cls.prototype[key] = stringifier;
        }
    }
}
exports.makePrintableBson = makePrintableBson;
//# sourceMappingURL=printable-bson.js.map