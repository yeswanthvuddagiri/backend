"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggingAndTelemetry = void 0;
exports.setupLoggingAndTelemetry = setupLoggingAndTelemetry;
const mongodb_redact_1 = __importDefault(require("mongodb-redact"));
const history_1 = require("@mongosh/history");
const util_1 = require("util");
const mongodb_log_writer_1 = require("mongodb-log-writer");
const mongodb_log_writer_2 = require("mongodb-log-writer");
const devtools_connect_1 = require("@mongodb-js/devtools-connect");
const helpers_1 = require("./helpers");
const stream_1 = require("stream");
const device_id_1 = require("@mongodb-js/device-id");
function setupLoggingAndTelemetry(props) {
    const loggingAndTelemetry = new LoggingAndTelemetry(props);
    loggingAndTelemetry.setup();
    return loggingAndTelemetry;
}
class LoggingAndTelemetry {
    constructor({ bus, analytics, userTraits, mongoshVersion, deviceId, }) {
        this.pendingBusEvents = [];
        this.pendingTelemetryEvents = [];
        this.isSetup = false;
        this.isBufferingBusEvents = false;
        this.isBufferingTelemetryEvents = false;
        this.setupTelemetryPromise = Promise.resolve();
        this.telemetrySetupAbort = new AbortController();
        this.busEventState = {
            hasStartedMongoshRepl: false,
            apiCallTracking: {
                isEnabled: false,
                apiCalls: new helpers_1.MultiSet(),
                deprecatedApiCalls: new helpers_1.MultiSet(),
            },
            usesShellOption: false,
            telemetryAnonymousId: undefined,
            userId: undefined,
        };
        this.bus = bus;
        this.analytics = analytics;
        this.log = LoggingAndTelemetry.dummyLogger;
        this.userTraits = userTraits;
        this.mongoshVersion = mongoshVersion;
        this.deviceId = deviceId;
    }
    setup() {
        if (this.isSetup) {
            throw new Error('Setup can only be called once.');
        }
        this.isBufferingTelemetryEvents = true;
        this.isBufferingBusEvents = true;
        this.setupTelemetryPromise = this.setupTelemetry();
        this.setupBusEventListeners();
        this.isSetup = true;
    }
    flush() {
        this.runAndClearPendingBusEvents();
        this.telemetrySetupAbort.abort();
    }
    async setupTelemetry() {
        if (!this.deviceId) {
            try {
                const getMachineId = require('native-machine-id').getMachineId;
                this.deviceId = await (0, device_id_1.getDeviceId)({
                    getMachineId: () => getMachineId({ raw: true }),
                    onError: (reason, error) => {
                        if (reason === 'abort') {
                            return;
                        }
                        this.bus.emit('mongosh:error', error, 'telemetry');
                    },
                    abortSignal: this.telemetrySetupAbort.signal,
                });
            }
            catch (error) {
                this.deviceId = 'unknown';
                this.bus.emit('mongosh:error', error, 'telemetry');
            }
        }
        this.runAndClearPendingTelemetryEvents();
    }
    attachLogger(logger) {
        if (!this.isSetup) {
            throw new Error('Run setup() before setting up the log writer.');
        }
        if (this.log !== LoggingAndTelemetry.dummyLogger) {
            throw new Error('Previously set logger has not been detached. Run detachLogger() before setting.');
        }
        this.log = logger;
        this.runAndClearPendingBusEvents();
        this.bus.emit('mongosh:log-initialized');
    }
    detachLogger() {
        this.log = LoggingAndTelemetry.dummyLogger;
        this.flush();
    }
    runAndClearPendingBusEvents() {
        let pendingEvent;
        while ((pendingEvent = this.pendingBusEvents.shift())) {
            pendingEvent();
        }
        this.isBufferingBusEvents = false;
    }
    runAndClearPendingTelemetryEvents() {
        let pendingEvent;
        while ((pendingEvent = this.pendingTelemetryEvents.shift())) {
            pendingEvent();
        }
        this.isBufferingTelemetryEvents = false;
    }
    setupBusEventListeners() {
        const onBus = (event, listener) => {
            this.bus.on(event, ((...args) => {
                if (this.isBufferingBusEvents) {
                    this.pendingBusEvents.push(() => listener(...args));
                    return;
                }
                listener(...args);
            }));
            return this.bus;
        };
        const getUserTraits = () => {
            var _a;
            return ({
                ...this.userTraits,
                device_id: (_a = this.deviceId) !== null && _a !== void 0 ? _a : 'unknown',
                session_id: this.log.logId,
            });
        };
        const getTrackingProperties = () => ({
            mongosh_version: this.mongoshVersion,
            session_id: this.log.logId,
        });
        const getTelemetryUserIdentity = () => {
            var _a;
            return {
                anonymousId: (_a = this.busEventState.telemetryAnonymousId) !== null && _a !== void 0 ? _a : this.busEventState.userId,
            };
        };
        const track = (message) => {
            const callback = () => this.analytics.track({
                ...getTelemetryUserIdentity(),
                ...message,
                properties: {
                    ...getTrackingProperties(),
                    ...message.properties,
                },
            });
            if (this.isBufferingTelemetryEvents) {
                this.pendingTelemetryEvents.push(callback);
            }
            else {
                callback();
            }
        };
        const identify = () => {
            const callback = () => this.analytics.identify({
                ...getTelemetryUserIdentity(),
                traits: getUserTraits(),
            });
            if (this.isBufferingTelemetryEvents) {
                this.pendingTelemetryEvents.push(callback);
            }
            else {
                callback();
            }
        };
        onBus('mongosh:start-mongosh-repl', (ev) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000002), 'repl', 'Started REPL', ev);
            this.busEventState.hasStartedMongoshRepl = true;
        });
        onBus('mongosh:start-loading-cli-scripts', (event) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000003), 'repl', 'Start loading CLI scripts');
            this.busEventState.usesShellOption = event.usesShellOption;
        });
        onBus('mongosh:connect', (args) => {
            const { uri, resolved_hostname, ...argsWithoutUriAndHostname } = args;
            const connectionUri = uri && (0, history_1.redactURICredentials)(uri);
            const atlasHostname = {
                atlas_hostname: args.is_atlas ? resolved_hostname : null,
            };
            const properties = {
                ...argsWithoutUriAndHostname,
                ...atlasHostname,
            };
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000004), 'connect', 'Connecting to server', {
                userId: this.busEventState.userId,
                telemetryAnonymousId: this.busEventState.telemetryAnonymousId,
                connectionUri,
                ...properties,
            });
            track({
                event: 'New Connection',
                properties,
            });
        });
        onBus('mongosh:start-session', (args) => {
            const normalizedTimingsArray = Object.entries(args.timings).map(([key, duration]) => {
                const snakeCaseKey = (0, helpers_1.toSnakeCase)(key);
                return [snakeCaseKey, duration];
            });
            const normalizedTimings = Object.fromEntries(normalizedTimingsArray);
            track({
                event: 'Startup Time',
                properties: {
                    is_interactive: args.isInteractive,
                    js_context: args.jsContext,
                    ...normalizedTimings,
                },
            });
        });
        onBus('mongosh:new-user', (newTelemetryUserIdentity) => {
            if (!newTelemetryUserIdentity.anonymousId) {
                this.busEventState.userId = newTelemetryUserIdentity.userId;
            }
            this.busEventState.telemetryAnonymousId =
                newTelemetryUserIdentity.anonymousId;
            identify();
        });
        onBus('mongosh:update-user', (updatedTelemetryUserIdentity) => {
            if (updatedTelemetryUserIdentity.anonymousId) {
                this.busEventState.telemetryAnonymousId =
                    updatedTelemetryUserIdentity.anonymousId;
            }
            else {
                this.busEventState.userId = updatedTelemetryUserIdentity.userId;
            }
            identify();
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000005), 'config', 'User updated');
        });
        onBus('mongosh:error', (error, context) => {
            const mongoshError = error;
            this.log[context === 'fatal' ? 'fatal' : 'error']('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000006), context, `${mongoshError.name}: ${mongoshError.message}`, error);
            if (error.name.includes('Mongosh')) {
                track({
                    event: 'Error',
                    properties: {
                        name: mongoshError.name,
                        code: mongoshError.code,
                        scope: mongoshError.scope,
                        metadata: mongoshError.metadata,
                    },
                });
            }
        });
        onBus('mongosh:write-custom-log', (event) => {
            this.log[event.method]('MONGOSH-SCRIPTS', (0, mongodb_log_writer_2.mongoLogId)(1000000054), 'custom-log', event.message, event.attr, event.level);
        });
        onBus('mongosh:globalconfig-load', (args) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000048), 'config', 'Loading global configuration file', args);
        });
        onBus('mongosh:evaluate-input', (args) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000007), 'repl', 'Evaluating input', args);
        });
        onBus('mongosh:use', (args) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000008), 'shell-api', 'Used "use" command', args);
            track({
                event: 'Use',
            });
        });
        onBus('mongosh:show', (args) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000009), 'shell-api', 'Used "show" command', args);
            track({
                event: 'Show',
                properties: {
                    method: args.method,
                },
            });
        });
        onBus('mongosh:setCtx', (args) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000010), 'shell-api', 'Initialized context', args);
        });
        onBus('mongosh:api-call-with-arguments', (args) => {
            let arg;
            try {
                arg = JSON.parse(JSON.stringify(args));
            }
            catch (_a) {
                arg = { _inspected: (0, util_1.inspect)(args) };
            }
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000011), 'shell-api', 'Performed API call', (0, mongodb_redact_1.default)(arg));
        });
        onBus('mongosh:api-load-file', (args) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000012), 'shell-api', 'Loading file via load()', args);
            track({
                event: this.busEventState.hasStartedMongoshRepl
                    ? 'Script Loaded'
                    : 'Script Loaded CLI',
                properties: {
                    nested: args.nested,
                    ...(this.busEventState.hasStartedMongoshRepl
                        ? {}
                        : { shell: this.busEventState.usesShellOption }),
                },
            });
        });
        onBus('mongosh:eval-cli-script', () => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000013), 'repl', 'Evaluating script passed on the command line');
            track({
                event: 'Script Evaluated',
                properties: {
                    shell: this.busEventState.usesShellOption,
                },
            });
        });
        onBus('mongosh:mongoshrc-load', () => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000014), 'repl', 'Loading .mongoshrc.js');
            track({
                event: 'Mongoshrc Loaded',
            });
        });
        onBus('mongosh:mongoshrc-mongorc-warn', () => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000015), 'repl', 'Warning about .mongorc.js/.mongoshrc.js mismatch');
            track({
                event: 'Mongorc Warning',
            });
        });
        onBus('mongosh:crypt-library-load-skip', (ev) => {
            this.log.info('AUTO-ENCRYPTION', (0, mongodb_log_writer_2.mongoLogId)(1000000050), 'crypt-library', 'Skipping shared library candidate', ev);
        });
        onBus('mongosh:crypt-library-load-found', (ev) => {
            this.log.warn('AUTO-ENCRYPTION', (0, mongodb_log_writer_2.mongoLogId)(1000000051), 'crypt-library', 'Accepted shared library candidate', {
                cryptSharedLibPath: ev.cryptSharedLibPath,
                expectedVersion: ev.expectedVersion.versionStr,
            });
        });
        onBus('mongosh-snippets:loaded', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000019), 'snippets', 'Loaded snippets', ev);
        });
        onBus('mongosh-snippets:npm-lookup', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000020), 'snippets', 'Performing npm lookup', ev);
        });
        onBus('mongosh-snippets:npm-lookup-stopped', () => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000021), 'snippets', 'npm lookup stopped');
        });
        onBus('mongosh-snippets:npm-download-failed', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000022), 'snippets', 'npm download failed', ev);
        });
        onBus('mongosh-snippets:npm-download-active', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000023), 'snippets', 'npm download active', ev);
        });
        onBus('mongosh-snippets:fetch-index', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000024), 'snippets', 'Fetching snippet index', ev);
        });
        onBus('mongosh-snippets:fetch-cache-invalid', () => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000025), 'snippets', 'Snippet cache invalid');
        });
        onBus('mongosh-snippets:fetch-index-error', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000026), 'snippets', 'Fetching snippet index failed', ev);
        });
        onBus('mongosh-snippets:fetch-index-done', () => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000027), 'snippets', 'Fetching snippet index done');
        });
        onBus('mongosh-snippets:package-json-edit-error', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000028), 'snippets', 'Modifying snippets package.json failed', ev);
        });
        onBus('mongosh-snippets:spawn-child', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000029), 'snippets', 'Spawning helper', ev);
        });
        onBus('mongosh-snippets:load-snippet', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000030), 'snippets', 'Loading snippet', ev);
        });
        onBus('mongosh-snippets:snippet-command', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000031), 'snippets', 'Running snippet command', ev);
            if (ev.args[0] === 'install') {
                track({
                    event: 'Snippet Install',
                });
            }
        });
        onBus('mongosh-snippets:transform-error', (ev) => {
            this.log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_2.mongoLogId)(1000000032), 'snippets', 'Rewrote error message', ev);
        });
        onBus('mongosh:api-call', (ev) => {
            if (!this.busEventState.apiCallTracking.isEnabled)
                return;
            const { apiCalls, deprecatedApiCalls } = this.busEventState.apiCallTracking;
            if (ev.deprecated) {
                deprecatedApiCalls.add({ class: ev.class, method: ev.method });
            }
            if (ev.callDepth === 0 && ev.isAsync) {
                apiCalls.add({ class: ev.class, method: ev.method });
            }
        });
        onBus('mongosh:evaluate-started', () => {
            const { apiCalls, deprecatedApiCalls } = this.busEventState.apiCallTracking;
            this.busEventState.apiCallTracking.isEnabled = true;
            deprecatedApiCalls.clear();
            apiCalls.clear();
        });
        onBus('mongosh:evaluate-finished', () => {
            const { apiCalls, deprecatedApiCalls } = this.busEventState.apiCallTracking;
            for (const [entry] of deprecatedApiCalls) {
                this.log.warn('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000033), 'shell-api', 'Deprecated API call', entry);
                track({
                    event: 'Deprecated Method',
                    properties: {
                        ...entry,
                    },
                });
            }
            for (const [entry, count] of apiCalls) {
                track({
                    event: 'API Call',
                    properties: {
                        ...entry,
                        count,
                    },
                });
            }
            deprecatedApiCalls.clear();
            apiCalls.clear();
            this.busEventState.apiCallTracking.isEnabled = false;
        });
        onBus('mongosh-sp:reset-connection-options', () => {
            this.log.info('MONGOSH-SP', (0, mongodb_log_writer_2.mongoLogId)(1000000040), 'connect', 'Reconnect because of changed connection options');
        });
        onBus('mongosh-editor:run-edit-command', (ev) => {
            this.log.error('MONGOSH-EDITOR', (0, mongodb_log_writer_2.mongoLogId)(1000000047), 'editor', 'Open external editor', (0, mongodb_redact_1.default)(ev));
        });
        onBus('mongosh-editor:read-vscode-extensions-done', (ev) => {
            this.log.error('MONGOSH-EDITOR', (0, mongodb_log_writer_2.mongoLogId)(1000000043), 'editor', 'Reading vscode extensions from file system succeeded', ev);
        });
        onBus('mongosh-editor:read-vscode-extensions-failed', (ev) => {
            this.log.error('MONGOSH-EDITOR', (0, mongodb_log_writer_2.mongoLogId)(1000000044), 'editor', 'Reading vscode extensions from file system failed', {
                ...ev,
                error: ev.error.message,
            });
        });
        onBus('mongosh:fetching-update-metadata', (ev) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000052), 'startup', 'Fetching update metadata', {
                ...ev,
            });
        });
        onBus('mongosh:fetching-update-metadata-complete', (ev) => {
            this.log.info('MONGOSH', (0, mongodb_log_writer_2.mongoLogId)(1000000053), 'startup', 'Fetching update metadata complete', {
                ...ev,
            });
        });
        (0, devtools_connect_1.hookLogger)(this.bus, {
            info: (...args) => {
                return this.log.info(...args);
            },
            warn: (...args) => {
                return this.log.warn(...args);
            },
            error: (...args) => {
                return this.log.error(...args);
            },
            mongoLogId: (...args) => {
                return this.log.mongoLogId(...args);
            },
        }, 'mongosh', (uri) => (0, history_1.redactURICredentials)(uri));
    }
}
exports.LoggingAndTelemetry = LoggingAndTelemetry;
LoggingAndTelemetry.dummyLogger = new mongodb_log_writer_1.MongoLogWriter('', null, new stream_1.Writable({
    write(chunk, encoding, callback) {
        callback();
    },
}));
//# sourceMappingURL=logging-and-telemetry.js.map