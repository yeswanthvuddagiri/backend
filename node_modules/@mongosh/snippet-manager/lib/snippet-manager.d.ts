import type { ShellPlugin, ShellInstanceState } from '@mongosh/shell-api';
import type { SnippetShellUserConfig, MongoshBus } from '@mongosh/types';
import { z } from 'zod';
import type { AgentWithInitialize, DevtoolsProxyOptions, Response } from '@mongodb-js/devtools-proxy-support';
export interface SnippetOptions {
    installdir: string;
    instanceState: ShellInstanceState;
    skipInitialIndexLoad?: boolean;
    proxyOptions?: DevtoolsProxyOptions | AgentWithInitialize;
}
declare const errorMatcherSchema: z.ZodObject<{
    message: z.ZodString;
    matches: z.ZodArray<z.ZodType<RegExp, z.ZodTypeDef, RegExp>, "many">;
}, "strip", z.ZodTypeAny, {
    message: string;
    matches: RegExp[];
}, {
    message: string;
    matches: RegExp[];
}>;
declare const indexDescriptionSchema: z.ZodObject<{
    name: z.ZodString;
    snippetName: z.ZodString;
    installSpec: z.ZodOptional<z.ZodString>;
    version: z.ZodString;
    description: z.ZodString;
    license: z.ZodString;
    readme: z.ZodString;
    errorMatchers: z.ZodOptional<z.ZodArray<z.ZodObject<{
        message: z.ZodString;
        matches: z.ZodArray<z.ZodType<RegExp, z.ZodTypeDef, RegExp>, "many">;
    }, "strip", z.ZodTypeAny, {
        message: string;
        matches: RegExp[];
    }, {
        message: string;
        matches: RegExp[];
    }>, "many">>;
}, "strip", z.ZodTypeAny, {
    name: string;
    snippetName: string;
    version: string;
    description: string;
    license: string;
    readme: string;
    installSpec?: string | undefined;
    errorMatchers?: {
        message: string;
        matches: RegExp[];
    }[] | undefined;
}, {
    name: string;
    snippetName: string;
    version: string;
    description: string;
    license: string;
    readme: string;
    installSpec?: string | undefined;
    errorMatchers?: {
        message: string;
        matches: RegExp[];
    }[] | undefined;
}>;
declare const indexFileSchema: z.ZodObject<{
    indexFileVersion: z.ZodNumber;
    metadata: z.ZodObject<{
        homepage: z.ZodString;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        homepage: z.ZodString;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        homepage: z.ZodString;
    }, z.ZodTypeAny, "passthrough">>;
    index: z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        snippetName: z.ZodString;
        installSpec: z.ZodOptional<z.ZodString>;
        version: z.ZodString;
        description: z.ZodString;
        license: z.ZodString;
        readme: z.ZodString;
        errorMatchers: z.ZodOptional<z.ZodArray<z.ZodObject<{
            message: z.ZodString;
            matches: z.ZodArray<z.ZodType<RegExp, z.ZodTypeDef, RegExp>, "many">;
        }, "strip", z.ZodTypeAny, {
            message: string;
            matches: RegExp[];
        }, {
            message: string;
            matches: RegExp[];
        }>, "many">>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        snippetName: string;
        version: string;
        description: string;
        license: string;
        readme: string;
        installSpec?: string | undefined;
        errorMatchers?: {
            message: string;
            matches: RegExp[];
        }[] | undefined;
    }, {
        name: string;
        snippetName: string;
        version: string;
        description: string;
        license: string;
        readme: string;
        installSpec?: string | undefined;
        errorMatchers?: {
            message: string;
            matches: RegExp[];
        }[] | undefined;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    indexFileVersion: number;
    metadata: {
        homepage: string;
    } & {
        [k: string]: unknown;
    };
    index: {
        name: string;
        snippetName: string;
        version: string;
        description: string;
        license: string;
        readme: string;
        installSpec?: string | undefined;
        errorMatchers?: {
            message: string;
            matches: RegExp[];
        }[] | undefined;
    }[];
}, {
    indexFileVersion: number;
    metadata: {
        homepage: string;
    } & {
        [k: string]: unknown;
    };
    index: {
        name: string;
        snippetName: string;
        version: string;
        description: string;
        license: string;
        readme: string;
        installSpec?: string | undefined;
        errorMatchers?: {
            message: string;
            matches: RegExp[];
        }[] | undefined;
    }[];
}>;
export type ErrorMatcher = z.infer<typeof errorMatcherSchema>;
export type SnippetIndexFile = z.infer<typeof indexFileSchema> & {
    sourceURL: string;
};
export type SnippetDescription = z.infer<typeof indexDescriptionSchema>;
export declare class SnippetManager implements ShellPlugin {
    _instanceState: ShellInstanceState;
    installdir: string;
    repos: SnippetIndexFile[] | null;
    load: (filename: string) => Promise<void>;
    require: any;
    config: {
        get<T extends keyof SnippetShellUserConfig>(key: T): Promise<SnippetShellUserConfig[T]>;
    };
    print: (...args: any[]) => Promise<void>;
    npmArgv: string[];
    inflightFetchIndexPromise: Promise<SnippetIndexFile[]> | null;
    fetch: (url: string) => Promise<Response>;
    constructor({ installdir, instanceState, skipInitialIndexLoad, proxyOptions, }: SnippetOptions);
    static create(options: SnippetOptions): SnippetManager;
    get messageBus(): MongoshBus;
    prepareNpm(): Promise<string[]>;
    prepareIndex(refreshMode?: 'force-refresh' | 'allow-cached'): Promise<SnippetIndexFile[]>;
    get snippets(): SnippetDescription[];
    registryBaseUrl(): Promise<string>;
    ensureSetup(): Promise<string[]>;
    editPackageJSON<T>(fn: (pjson: any) => T): Promise<T>;
    runNpm(...npmArgs: string[]): Promise<string>;
    execFile([cmd, ...args]: string[]): Promise<string>;
    search(): Promise<string>;
    loadAllSnippets(autoloadMode?: 'always' | 'only-autoload'): Promise<void>;
    runSnippetCommand(args: string[]): Promise<string>;
    runInstallLikeCmd(args: string[]): Promise<string>;
    helpText(snippet?: string): Promise<string>;
    showInfo(): Promise<string>;
    transformError(err: Error): Error;
}
export {};
