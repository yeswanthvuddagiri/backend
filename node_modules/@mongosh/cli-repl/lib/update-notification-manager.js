"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateNotificationManager = void 0;
const semver_1 = __importDefault(require("semver"));
const fs_1 = require("fs");
const devtools_proxy_support_1 = require("@mongodb-js/devtools-proxy-support");
class UpdateNotificationManager {
    constructor({ proxyOptions = {}, } = {}) {
        this.latestKnownMongoshVersion = undefined;
        this.currentVersionGreetingCTA = undefined;
        this.localFilesystemFetchInProgress = undefined;
        this.fetch = (0, devtools_proxy_support_1.createFetch)(proxyOptions);
    }
    async getLatestVersionIfMoreRecent(currentVersion) {
        try {
            await this.localFilesystemFetchInProgress;
        }
        catch (_a) {
        }
        if (!this.latestKnownMongoshVersion)
            return null;
        if (currentVersion &&
            !semver_1.default.gt(this.latestKnownMongoshVersion, currentVersion))
            return null;
        if (currentVersion && semver_1.default.prerelease(currentVersion))
            return null;
        return this.latestKnownMongoshVersion;
    }
    async getGreetingCTAForCurrentVersion() {
        var _a;
        try {
            await this.localFilesystemFetchInProgress;
        }
        catch (_b) {
        }
        return (_a = this.currentVersionGreetingCTA) === null || _a === void 0 ? void 0 : _a.chunks;
    }
    async fetchUpdateMetadata(updateURL, localFilePath, currentVersion) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        let localFileContents;
        await (this.localFilesystemFetchInProgress = (async () => {
            let localFileText = '';
            try {
                localFileText = await fs_1.promises.readFile(localFilePath, 'utf-8');
            }
            catch (err) {
                if (!(err &&
                    typeof err === 'object' &&
                    'code' in err &&
                    err.code === 'ENOENT'))
                    throw err;
            }
            try {
                localFileContents = JSON.parse(localFileText);
            }
            catch (_a) {
            }
            if ((localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.updateURL) !== updateURL) {
                localFileContents = undefined;
            }
            if (localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.latestKnownMongoshVersion) {
                this.latestKnownMongoshVersion =
                    localFileContents.latestKnownMongoshVersion;
            }
            if ((localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.cta) && currentVersion in localFileContents.cta) {
                this.currentVersionGreetingCTA = localFileContents.cta[currentVersion];
            }
            this.localFilesystemFetchInProgress = undefined;
        })());
        if ((localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.lastChecked) &&
            Date.now() - localFileContents.lastChecked < 86400000) {
            return;
        }
        const response = await this.fetch(updateURL, {
            headers: (localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.etag)
                ? { 'if-none-match': localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.etag }
                : {},
        });
        if (response.status === 304) {
            (_a = response.body) === null || _a === void 0 ? void 0 : _a.once('error', () => {
            }).resume();
            localFileContents = { ...localFileContents, lastChecked: Date.now() };
            await fs_1.promises.writeFile(localFilePath, JSON.stringify(localFileContents));
            return;
        }
        if (!response.ok || !response.body) {
            throw new Error(`Unexpected status code fetching ${updateURL}: ${response.status} ${response.statusText}`);
        }
        const jsonContents = (await response.json());
        this.latestKnownMongoshVersion = (_e = (_d = (_c = (_b = jsonContents === null || jsonContents === void 0 ? void 0 : jsonContents.versions) === null || _b === void 0 ? void 0 : _b.map((v) => v.version)) === null || _c === void 0 ? void 0 : _c.filter((v) => !semver_1.default.prerelease(v))) === null || _d === void 0 ? void 0 : _d.sort(semver_1.default.rcompare)) === null || _e === void 0 ? void 0 : _e[0];
        this.currentVersionGreetingCTA =
            (_h = (_g = (_f = jsonContents === null || jsonContents === void 0 ? void 0 : jsonContents.versions) === null || _f === void 0 ? void 0 : _f.find((v) => v.version === currentVersion)) === null || _g === void 0 ? void 0 : _g.cta) !== null && _h !== void 0 ? _h : jsonContents === null || jsonContents === void 0 ? void 0 : jsonContents.cta;
        const latestKnownVersionCTA = (_l = (_k = (_j = jsonContents === null || jsonContents === void 0 ? void 0 : jsonContents.versions) === null || _j === void 0 ? void 0 : _j.find((v) => v.version === this.latestKnownMongoshVersion)) === null || _k === void 0 ? void 0 : _k.cta) !== null && _l !== void 0 ? _l : jsonContents === null || jsonContents === void 0 ? void 0 : jsonContents.cta;
        localFileContents = {
            updateURL,
            lastChecked: Date.now(),
            etag: (_m = response.headers.get('etag')) !== null && _m !== void 0 ? _m : undefined,
            latestKnownMongoshVersion: this.latestKnownMongoshVersion,
            cta: {
                [currentVersion]: this.currentVersionGreetingCTA,
                ...(this.latestKnownMongoshVersion &&
                    this.latestKnownMongoshVersion !== currentVersion && {
                    [this.latestKnownMongoshVersion]: latestKnownVersionCTA,
                }),
            },
        };
        await fs_1.promises.writeFile(localFilePath, JSON.stringify(localFileContents));
    }
}
exports.UpdateNotificationManager = UpdateNotificationManager;
//# sourceMappingURL=update-notification-manager.js.map