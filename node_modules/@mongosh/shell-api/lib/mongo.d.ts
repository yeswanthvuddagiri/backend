import { ShellApiClass } from './decorators';
import type { ChangeStreamOptions, Document, ListDatabasesOptions, ReadConcernLevel, ReadPreference, ReadPreferenceLike, ReadPreferenceMode, ServiceProvider, AutoEncryptionOptions as SPAutoEncryption, ServerApi, ServerApiVersion, WriteConcern, AnyClientBulkWriteModel, ClientBulkWriteOptions } from '@mongosh/service-provider-core';
import type { ConnectionInfo } from '@mongosh/arg-parser';
import type { DatabaseWithSchema } from './database';
import type ShellInstanceState from './shell-instance-state';
import { ClientBulkWriteResult } from './result';
import { CommandResult } from './result';
import { asPrintable } from './enums';
import Session from './session';
import type { GenericServerSideSchema, StringKey } from './helpers';
import ChangeStreamCursor from './change-stream-cursor';
import type { ClientSideFieldLevelEncryptionOptions } from './field-level-encryption';
import { KeyVault, ClientEncryption } from './field-level-encryption';
import type { CollectionWithSchema } from './collection';
import type { ShellBson } from './shell-bson';
export default class Mongo<M extends GenericServerSideSchema = GenericServerSideSchema> extends ShellApiClass {
    private __serviceProvider;
    readonly _databases: Record<StringKey<M>, DatabaseWithSchema<M>>;
    _instanceState: ShellInstanceState;
    _connectionInfo: ConnectionInfo;
    private _explicitEncryptionOnly;
    private _keyVault;
    private _clientEncryption;
    private _readPreferenceWasExplicitlyRequested;
    private _cachedDatabaseNames;
    constructor(instanceState: ShellInstanceState, uri?: string | Mongo, fleOptions?: ClientSideFieldLevelEncryptionOptions, otherOptions?: {
        api?: ServerApi | ServerApiVersion;
    }, sp?: ServiceProvider);
    get _uri(): string;
    get _fleOptions(): SPAutoEncryption | undefined;
    get _serviceProvider(): ServiceProvider;
    set _serviceProvider(sp: ServiceProvider);
    _displayBatchSize(): Promise<number>;
    [asPrintable](): string;
    private _emitMongoApiCall;
    connect(username?: string, password?: string): Promise<void>;
    _getDb<K extends StringKey<M>>(name: K): DatabaseWithSchema<M, M[K]>;
    getDB<K extends StringKey<M>>(db: K): DatabaseWithSchema<M, M[K]>;
    getCollection<KD extends StringKey<M>, KC extends StringKey<M[KD]>>(name: `${KD}.${KC}`): CollectionWithSchema<M, M[KD], M[KD][KC]>;
    getURI(): string;
    use(db: StringKey<M>): string;
    _listDatabases(opts?: ListDatabasesOptions): Promise<{
        databases: {
            name: string;
            sizeOnDisk: number | ShellBson['Long'];
            empty: boolean;
        }[];
        ok: 1;
    }>;
    _getDatabaseNamesForCompletion(): Promise<string[]>;
    getDBs(options?: ListDatabasesOptions): Promise<{
        databases: {
            name: string;
            sizeOnDisk: number | ShellBson['Long'];
            empty: boolean;
        }[];
        ok: 1;
    }>;
    bulkWrite(models: AnyClientBulkWriteModel<Document>[], options?: ClientBulkWriteOptions): Promise<ClientBulkWriteResult>;
    getDBNames(options?: ListDatabasesOptions): Promise<StringKey<M>[]>;
    show(cmd: string, arg?: string, tracked?: boolean): Promise<CommandResult>;
    close(force?: boolean): Promise<void>;
    _suspend(): Promise<() => Promise<void>>;
    getReadPrefMode(): ReadPreferenceMode;
    getReadPrefTagSet(): Record<string, string>[] | undefined;
    getReadPref(): ReadPreference;
    _getExplicitlyRequestedReadPref(): {
        readPreference: ReadPreference;
    } | undefined;
    getReadConcern(): string | undefined;
    getWriteConcern(): WriteConcern | undefined;
    setReadPref(mode: ReadPreferenceLike, tagSet?: Record<string, string>[], hedgeOptions?: Document): Promise<void>;
    setReadConcern(level: ReadConcernLevel): Promise<void>;
    setWriteConcern(concern: WriteConcern): Promise<void>;
    setWriteConcern(wValue: string | number, wtimeoutMSValue?: number | undefined, jValue?: boolean | undefined): Promise<void>;
    startSession(options?: Document): Session;
    setCausalConsistency(): void;
    isCausalConsistency(): void;
    setSlaveOk(): void;
    setSecondaryOk(): Promise<void>;
    watch(pipeline?: Document[] | ChangeStreamOptions, options?: ChangeStreamOptions): Promise<ChangeStreamCursor>;
    getClientEncryption(): ClientEncryption;
    getKeyVault(): Promise<KeyVault>;
    convertShardKeyToHashed(value: any): Promise<unknown>;
}
