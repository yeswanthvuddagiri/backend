import type { Database, DatabaseWithSchema } from './database';
import { ShellApiWithMongoClass } from './decorators';
import type { Document, CheckMetadataConsistencyOptions } from '@mongosh/service-provider-core';
import type { ShardInfo, ShardingStatusResult, GenericDatabaseSchema, GenericServerSideSchema } from './helpers';
import { asPrintable } from './enums';
import type { UpdateResult } from './result';
import { CommandResult } from './result';
import type Mongo from './mongo';
import type AggregationCursor from './aggregation-cursor';
import type RunCommandCursor from './run-command-cursor';
export default class Shard<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = GenericDatabaseSchema> extends ShellApiWithMongoClass {
    _database: DatabaseWithSchema<M, D>;
    constructor(database: DatabaseWithSchema<M, D> | Database<M, D>);
    get _mongo(): Mongo<M>;
    [asPrintable](): string;
    private _emitShardApiCall;
    enableSharding(database: string, primaryShard?: string): Promise<Document>;
    commitReshardCollection(namespace: string): Promise<Document>;
    abortReshardCollection(namespace: string): Promise<Document>;
    shardCollection(namespace: string, key: Document, unique?: boolean | Document, options?: Document): Promise<Document>;
    reshardCollection(namespace: string, key: Document, unique?: boolean | Document, options?: Document): Promise<Document>;
    _runShardCollection(command: 'shardCollection' | 'reshardCollection', namespace: string, key: Document, unique?: boolean | Document, options?: Document): Promise<Document>;
    status(verbose?: boolean, configDB?: DatabaseWithSchema<M, D>): Promise<CommandResult<ShardingStatusResult>>;
    addShard(url: string): Promise<Document>;
    addShardToZone(shard: string, zone: string): Promise<Document>;
    addShardTag(shard: string, tag: string): Promise<Document>;
    updateZoneKeyRange(namespace: string, min: Document, max: Document, zone: string | null): Promise<Document>;
    addTagRange(namespace: string, min: Document, max: Document, zone: string): Promise<Document>;
    removeRangeFromZone(ns: string, min: Document, max: Document): Promise<Document>;
    removeTagRange(ns: string, min: Document, max: Document): Promise<Document>;
    removeShardFromZone(shard: string, zone: string): Promise<Document>;
    removeShardTag(shard: string, tag: string): Promise<Document>;
    enableAutoSplit(): Promise<UpdateResult>;
    disableAutoSplit(): Promise<UpdateResult>;
    splitAt(ns: string, query: Document): Promise<Document>;
    splitFind(ns: string, query: Document): Promise<Document>;
    moveChunk(ns: string, query: Document, destination: string): Promise<Document>;
    moveRange(ns: string, toShard: string, min?: Document, max?: Document): Promise<Document>;
    balancerCollectionStatus(ns: string): Promise<Document>;
    enableBalancing(ns: string): Promise<UpdateResult>;
    disableBalancing(ns: string): Promise<UpdateResult>;
    getBalancerState(): Promise<boolean>;
    isBalancerRunning(): Promise<Document>;
    startBalancer(timeout?: number): Promise<Document>;
    stopBalancer(timeout?: number): Promise<Document>;
    setBalancerState(state: boolean): Promise<Document>;
    getShardedDataDistribution(options?: {}): Promise<AggregationCursor>;
    startAutoMerger(): Promise<UpdateResult>;
    stopAutoMerger(): Promise<UpdateResult>;
    isAutoMergerEnabled(): Promise<boolean>;
    disableAutoMerger(ns: string): Promise<UpdateResult>;
    enableAutoMerger(ns: string): Promise<UpdateResult>;
    checkMetadataConsistency(options?: CheckMetadataConsistencyOptions): Promise<RunCommandCursor>;
    shardAndDistributeCollection(ns: string, key: Document, unique?: boolean | Document, options?: Document): Promise<Document>;
    moveCollection(ns: string, toShard: string): Promise<Document>;
    abortMoveCollection(ns: string): Promise<Document>;
    unshardCollection(ns: string, toShard: string): Promise<Document>;
    abortUnshardCollection(ns: string): Promise<Document>;
    listShards(): Promise<ShardInfo[]>;
    isConfigShardEnabled(): Promise<Document>;
}
